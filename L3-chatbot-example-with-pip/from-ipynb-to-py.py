import json
import os
import re
import sys
from pathlib import Path

"""
notebook to py

Utility to extract Python code from a Jupyter notebook (L3.ipynb) and write it
into this file. Run from the same folder as L3.ipynb or pass a path to the notebook.

Usage:
    python L3-chatbot-example.py              # looks for L3.ipynb in cwd, writes L3-chatbot-example.py
    python L3-chatbot-example.py path/to/L3.ipynb
"""


NOTEBOOK_DEFAULT = "L3.ipynb"
OUTFILE = NOTEBOOK_DEFAULT + ".py" # Path(__file__).resolve()

MAGIC_RE = re.compile(r'^\s*%.*$', flags=re.MULTILINE)
GET_IPYTHON_RE = re.compile(r'get_ipython\([^)]*\)\.[^\n]*', flags=re.MULTILINE)


def clean_code(source: str) -> str:
    """
    Clean code cell contents:
    - remove line magics like %timeit
    - remove get_ipython(...) calls
    - optionally convert IPython shell escapes
    """
    s = source
    s = MAGIC_RE.sub("", s)
    s = GET_IPYTHON_RE.sub("", s)
    # remove stray leading/trailing blank lines
    s = "\n".join(line.rstrip() for line in s.splitlines())
    s = s.strip()
    return s


def notebook_to_py(nb_path: Path, out_path: Path, include_markdown_as_comments: bool = True) -> None:
    if not nb_path.exists():
        raise FileNotFoundError(f"Notebook not found: {nb_path}")

    with nb_path.open("r", encoding="utf-8") as f:
        nb = json.load(f)

    cells = nb.get("cells", [])
    parts = []
    parts.append(f"# Converted from {nb_path.name}\n# Autogenerated by notebook_to_py\n")

    for i, cell in enumerate(cells):
        ctype = cell.get("cell_type", "")
        source = "".join(cell.get("source", [])) if isinstance(cell.get("source", []), list) else cell.get("source", "")
        if not source:
            continue
        parts.append(f"\n# ----- cell {i} ({ctype}) -----\n")
        if ctype == "code":
            cleaned = clean_code(source)
            if cleaned:
                parts.append(cleaned + "\n")
        elif ctype == "markdown" and include_markdown_as_comments:
            # convert markdown to commented lines so context is preserved
            md_lines = ["# " + line if line.strip() != "" else "#" for line in source.splitlines()]
            parts.append("\n".join(md_lines) + "\n")
        else:
            # skip other cell types
            continue

    final = "\n".join(parts).rstrip() + "\n"
    with out_path.open("w", encoding="utf-8") as f:
        f.write(final)


def main():
    nb_arg = sys.argv[1] if len(sys.argv) > 1 else NOTEBOOK_DEFAULT
    out_arg = sys.argv[1] if len(sys.argv) > 1 else OUTFILE
    nb_path = Path(nb_arg).expanduser().resolve()
    out_path = Path(out_arg).with_suffix('.py').expanduser().resolve()
    try:
        notebook_to_py(nb_path, out_path, include_markdown_as_comments=True)
        print(f"Wrote Python code to {out_path}")
    except Exception as e:
        print("Error:", e)
        sys.exit(1)


if __name__ == "__main__":
    main()